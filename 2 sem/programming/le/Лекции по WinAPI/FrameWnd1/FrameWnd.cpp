/*
   Файл               : FrameWnd.cpp

   Проект             : простейшее приложение Win32API с
                        использованием стандартных функций API-SDK
                        (создается главное окно, в которое
                        производится вывод текста и графики)

   Microsoft Visual Studio C++ .NET 2005
*/

// Прекомпилируемый заголовочный файл
#include "stdafx.h"

// Прототипы используемых функций (!!! имена функций не системные
//   и могут быть иными - здесь нет связи с классами или
//   библиотеками)
LRESULT CALLBACK WndProc( HWND hwnd, UINT message, WPARAM wParam,
                          LPARAM lParam );
BOOL InitApplication( HINSTANCE hInstance );
BOOL InitInstance( HINSTANCE hInstance, int nCmdShow );

// Указатель на имя регистрируемого класса
LPCSTR                    szClassName = "FrameWndAPI";        
// Указатель на заголовок окна приложения
LPCSTR                  szTitle = "Создание Windows-приложения"
    " FrameWnd с использованием стандартных функций SDK-API";

// ****************************************************************
// Главная функция приложения
int WINAPI WinMain(                 // Возвращает TRUE при успехе
    // Дескриптор данного приложения
    HINSTANCE           hInstance,
    // Дескриптор предыдущей запущенной копии приложения. В
    //   Win32API этот параметр всегда равен NULL и оставлен
    //   исключительно для совместимости с версиями ниже четвертой.
    //   Связано это с тем, что каждое 32-разрядное приложение
    //   запускается в собственном адресном пространстве, в
    //   котором, естественно, нет никаких копий или других 
    //   приложений
    HINSTANCE           hPrevInstance,
    // Указатель на командную строку, которую можно в
    //   интегрированной среде разработки задать по команде
    //   "Properties" контекстного меню проекта в элементе "Program
    //   arguments" вкладки "Debugging"
    LPSTR               lpCmdLine,
    // Режим начального отображения главного окна приложения -
    //   после вызова параметр получает значение SW_SHOWNORMAL (1),
    //   что соответствует отображению окна в нормальном виде
    int                 nCmdShow )
{
    // Хотя параметр hPrevInstance в Win32API всегда равен NULL,
    //   все же продолжаем для совместимости проверять его значение
    if ( !hPrevInstance ) 
    {
        // Инициализируем приложение - подготавливаем данные класса
        //   окна и регистрируем его
        if ( !InitApplication( hInstance ) )
            return FALSE;
    }

    // Завершаем создание приложения - создаем и отображаем главное
    //   окно приложения
    if ( !InitInstance( hInstance, nCmdShow ) ) 
        return FALSE;  

    MSG                 msg;        // Для очередного сообщения
    // Стандартный цикл обработки сообщений
    while ( GetMessage( &msg, NULL, 0, 0 ) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    /*
       Данный цикл работает в течение всего времени выполнения
    программы. Каждая итерация представляет собой прием одного
    сообщения из очереди сообщений приложения. За это отвечает
    системная функция GetMessage( ), второй аргумент которой (NULL)
    говорит о том, что читаться должны сообщения, адресованные
    любому окну приложения. Третий и четвертый аргументы формируют
    фильтр сообщений, который ограничивает получаемые сообщения
    определенным диапазоном. В нашем случае эти аргументы нулевые
    и будут приниматься любые сообщения, адресованные данному
    приложению. Когда сообщение выбирается из очереди, оно
    помещается в специальную структуру с типом MSG, на которую
    указывает первый аргумент и которая выглядит следующим образом:
    typedef struct tagMSG
    {
        // Дескриптор (логический номер) окна, чья оконная
        //   процедура получает сообщение
        HWND            hwnd;
        UINT            message;    // Номер сообщения
        WPARAM          wParam;     // Дополнительная информация о
                                    //   сообщении, зависящая
        LPARAM          lParam;     //   от типа сообщения (wParam,
                                    //   lParam)
        DWORD           time;       // Время возникновения
                                    //   сообщения
        // Позиция указателя мыши на момент возникновения сообщения
        POINT           pt;
        } MSG;
           После того, как сообщение взято из очереди сообщений,
        оно передается в функцию TranslateMessage( ), которая
        вызывает драйвер клавиатуры ОС Windows для преобразования
        виртуальных кодов клавиш в ASCII-значения, которые ставятся
        в очередь программных событий в виде сообщения WM_CHAR. Это
        позволяет программе отличить, например, 'А' от 'а' без
        анализа состояния клавиши регистра. Эта функция необходима
        только тем приложениям, которые обрабатывают ввод данных с
        клавиатуры. Важность функции TranslateMessage( )
        заключается в том, что она позволяет пользователям выбирать
        команды меню не только шелчками мыши, но и путем нажатия
        клавиш.
           Последняя функция цикла - DispatchMessage( ) берет
        данные о сообщении из структуры msg и передает их в
        соответствующую оконную процедуру для обработки. После того
        как сообщение передано, снова вызывается функция
        GetMessage( ), чтобы взять из очереди следующее сообщение,
        если таковое имеется. За исключением WM_QUIT, каждое
        сообщение заставляет GetMessage( ) возвратить значение
        TRUE. Принимая сообщение WM_QUIT, программа выходит из
        цикла обработки сообщений и завершает работу.
           Важно понимать, что этот, или подобный ему, цикл без
        конца повторяется в течение всей жизни программы,
        написанной для ОС Windows.
    */

    return static_cast< int >( msg.wParam );
}

// ****************************************************************
/*
   Любое окно ОС Windows принадлежит одному из существующих в данный
момент в системе классов, который должен быть определен до того,
как окно будет отображено на экране. Класс окна задает наиболее
общие свойства окон, например, форму курсора при перемещении его в
область окна, или имя меню, определенного для окон этого класса.
   Другими словами, класс окна - это шаблон, в котором определяются
выбранные стили, шрифты, заголовки, пиктогаммы, размер,
расположение окна и т.д. Поскольку каждый класс имеет свою
структуру параметров окна, доступную всем, не происходит ненужного
дублирования данных. При этом следует учитывать, что имя класса
должно быть уникальным, чтобы не возникало конфликтов с классами
окон других приложений. Кроме того, два окна одного и того же
класса используют общую функцию окна (оконную процедуру) со всеми
ее вспомогательными функциями
*/
// Подготовка данных класса окна и его регистрация в ОС Windows
BOOL InitApplication(               // Возвращает TRUE при успешном
                                    //   завершении
    // Дескриптор (уникальное число), ассоциируемый с текущим
    //   приложением
    HINSTANCE           hInstance )
{
    // Сведения о регистрируемом классе
    WNDCLASS            wc;
    /*
       Объявление структуры WNDCLASS имеет вид:
    typedef struct tagWNDCLASSA 
    {
        // Определяет свойства окна, которые могут комбинороваться
        //   при помощи операции | (ИЛИ). При программировании для
        //   ОС Windows этот термин относится к набору параметров,
        //   каждый из которых управляется одним или двумя битами.
        //   Если этому полю присвоить значение NULL, то ОС Windows
        //   автоматически установит значения по умолчанию. Окно
        //   является основой приложения
        UINT            style;
        //   Для того, чтобы больше не возвращаться к этому
        //   вопросу, перечислим список допустимых стилей окна:
    // CS_BYTEALIGNCLIENT
    // Оказывает влияние на ширину окна, задавая для клиентной
    //   области окна выравнивание по границе байта. Это позволяет
    //   увеличить производительность операций рисования в окне
    // CS_BYTEALIGNWINDOW
    // Задает выравнивание ширины окна по границе байта. Это
    //   позволяет увеличить производительность некоторых типов
    //   операций, таких как перемещение и изменение размеров окна,
    //   рисование пунктов меню
    // CS_CLASSDC
    // Указывает, что все окна данного класса должны использовать
    //   один и тот же контекст устройства
    // CS_DBLCLKS
    // Служит для установки таймера после получения первого
    //   сообщения о нажатии кнопки мыши. Сообщение о двойном
    //   нажатии будет сформировано только в том случае, если
    //   второе нажатие произойдет по истечении определенного
    //   времени таймера. Обеспечивает всем окнам класса
    //   возможность воспринимать сообщения о двойном нажатии одной
    //   из кнопок мыши
    // CS_GLOBALCLASS
    // Позволяет приложению создавать окно этого класса, не
    //   считаясь со значением параметра hInstance. Если Вы не
    //   определите этот стиль, то параметр hInstance, передаваемый
    //   в функции создания окна, должен быть таким же, который
    //   передается в функцию RegisterClass( ). Другими словами,
    //   установка этого стиля позволяет создавать оконные классы,
    //   предназначенные для совместного использования несколькими
    //   приложениями
    // CS_HREDRAW
    // Определяет, что окно будет перерисовываться, как только
    //   изменится его горизонтальный размер
    // CS_VREDRAW
    // Определяет, что окно будет перерисовываться, как только
    //   изменится его вертикальный размер
    // CS_NOCLOSE
    // Запрещает пункт Close (Закрыть) системного меню. Этот стиль
    //   следует использовать с окнами, имеющими системное меню,
    //   которые не могут быть закрытыми пользователем
    // CS_OWNDC
    // Предоставляет частный контекст устройства для каждого окна в
    //   данном классе. Этот тип контекста устройства наиболее
    //   расточителен в смысле использования памяти, но
    //   обеспечивает самую высокую скорость реакции
    // CS_PARENTDC
    // Устанавливает, что дочерние окна не могут рисовать в своем
    //   родительском окне. Этот стиль обычно применяется для
    //   предварительно определенных классов, необходимых для
    //   создания элементов управления блоков диалога
    // CS_SAVEBITS
    // Предписывает системе сохранять копию части экрана,
    //   поврежденную окном. После удаления окна поврежденная часть
    //   может быть восстановлена. При этом Windows не посылает 
    //   сообщения WM_PAINT для перерисовки области, которую
    //   занимало окно. Этот стиль применяется для небольших окон,
    //   например меню или блоков диалога, которые появляются на
    //   экране на короткие промежутки времени
        WNDPROC         lpfnWndProc;// Адрес функции окна, которая
                                    //   обрабатывает сообщения для
                                    //   окон данного класса
        // Задает число байт, которое необходимо дополнительно
        //   запросить у ОС Windows под эту структуру для хранения
        //   собственных данных, присоединенных к классу. Это поле
        //   может иметь значение NULL
        int             cbClsExtra;
        // Задает число байт, которое необходимо дополнительно
        //   запросить у ОС Windows для размещения всех структур,
        //   создаваемых совместно с данным классом для хранения
        //   собственных данных, присоединенных к окну. Это поле
        //   также может иметь значение NULL
        int             cbWndExtra;
        // Кто создает определение класса. Это необходимо для
        //   служебных действий внутри ОС Windows. Когда
        //   завершается последний экземпляр программы, ОС Windows
        //   удаляет все связанные определения классов
        HINSTANCE       hInstance;
        // Определяет пиктограмму, которая будет использоваться для
        //   изображения приложения, например, на панели задач. Вы
        //   можете создать пиктограмму сами или использовать одну
        //   из предопределенных пиктограмм:
        //   IDI_APPLICATION - стандартная для приложения,
        //   IDI_HAND - знак "стоп",
        //   IDI_QYESTION - "вопросительный знак",
        //   IDI_EXCLAMATION - "восклицательный знак",
        //   IDI_ASTERISK - "информация"
        //   Это поле может иметь значение NULL
        HICON           hIcon;
        // Идентифицирует курсор мыши по умолчанию, используемый в
        //   данном окне. Если нет желания создавать свой курсор,
        //   то можно воспользоваться одним из предлставляемых
        //   системой:
        //   IDC_ARROW - стрелка;
        //   IDC_IBEAM - вертикальная черта;
        //   IDC_WAIT - песочные часы;
        //   IDC_CROSS - перекрестье;
        //   IDC_UPARROW - вертикальная стрелка;
        //   IDC_SIZE - четыре стрелки, указывающие в разные
        //              стороны;
        //   IDC_ICON - курсор, используемый при переносе файлов;
        //   IDC_SIZENWSE - двунаправленная стрелка
        //                  северо-запад/юго-восток;
        //   IDC_SIZENESW - двунаправленная стрелка
        //                  северо-восток/юго-запад;
        //   IDC_SIZEWE - двунаправленная стрелка восток/запад;
        //   IDC_SIZENS - двунаправленная стрелка север/юг
        // Имеются и другие предопределенные стили курсора - см.
        //   справку по функции LoadCursor( )
        HCURSOR         hCursor;
        // Задает цвет фона для окна. Для его определения можно
        //   воспользоваться любой из 20 системных констант цвета,
        //   которые определены в winuser.h:
        //   #define COLOR_SCROLLBAR            0
        //   #define COLOR_BACKGROUND           1
        //   #define COLOR_ACTIVECAPTION        2
        //   #define COLOR_INACTIVECAPTION      3
        //   #define COLOR_MENU                 4
        //   #define COLOR_WINDOW               5
        //   #define COLOR_WINDOWFRAME          6
        //   #define COLOR_MENUTEXT             7
        //   #define COLOR_WINDOWTEXT           8
        //   #define COLOR_CAPTIONTEXT          9
        //   #define COLOR_ACTIVEBORDER         10
        //   #define COLOR_INACTIVEBORDER       11
        //   #define COLOR_APPWORKSPACE         12
        //   #define COLOR_HIGHLIGHT            13
        //   #define COLOR_HIGHLIGHTTEXT        14
        //   #define COLOR_BTNFACE              15
        //   #define COLOR_BTNSHADOW            16
        //   #define COLOR_GRAYTEXT             17
        //   #define COLOR_BTNTEXT              18
        //   #define COLOR_INACTIVECAPTIONTEXT  19
        //   #define COLOR_BTNHIGHLIGHT         20
        // При использовании этих констант к их значению
        //   обязательно нужно добавлять единицу, т.к. первое
        //   значение для них равно нулю, а нуль является
        //   недействительным значением для логического номера
        //   кисти. Кроме того, необходимо выполнить приведение к
        //   типу HBRUSH - иначе компилятор выдаст сообщение об
        //   ошибке.
        // Если значение этого поля равно нулю, то приложение
        //   должно самостоятельно управлять заливкой фона окна при
        //   поступлении соответствующего сообщения
        HBRUSH          hbrBackground;
        // Указатель на имя меню окна, определенное в файле
        //   ресурсов. Это поле может иметь значение NULL
        LPCSTR          lpszMenuName;
        // Указатель на строку, содержащую имя класса (имя класса
        //   д.б. уникальным)
        LPCSTR          lpszClassName;
    } WNDCLASS;
    */

    // Заполняем структуру класса окна WNDCLASS - смысл
    //   инициализирующих значений рассмотрен выше
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = static_cast< WNDPROC >( WndProc );
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon( NULL, IDI_ASTERISK );
    wc.hCursor       = LoadCursor( NULL, IDC_CROSS );
    wc.hbrBackground = reinterpret_cast< HBRUSH >( COLOR_WINDOW+1 );
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = szClassName;

    // Регистрируем класс окна
    return RegisterClass( &wc );
    // Функция RegisterClass( ) определяет класс окна, которое
    //   выводится на экран. Все окна ОС Windows - объекты, каждый
    //   из которых имеет набор характерных черт. Заполняя
    //   структуру WNDCLASS, Вы сообщаете ОС Windows, какими хотите
    //   видеть конкретные объекты.
    // Чаще всего вообще не нужно думать о методе регистрации.
    //   Просто скопируйте приведенный фрагмент функции
    //   InitApplication( ) в приложение и вызывайте ее даже не
    //   думая о ее содержимом. Регистация класса окна не является
    //   чем-то таким, о чем необходимо постоянно заботиться - чаще
    //   всего фрагмент кода, отвечающий за нее, просто переносится
    //   из одного приложения в другое
} 

// ****************************************************************
// Создание окна
BOOL InitInstance(                  // Возвращает TRUE при успехе
    // Дескриптор текущего приложения 
    HINSTANCE           hInstance, 
    // Режим отображения главного окна - определяет в каком виде
    //   будет отображено окно приложения
    int                 nCmdShow )
{
    // Дескриптор главного окна
    HWND                hWnd;

    // Создание окна
    hWnd = CreateWindow(
        // Указатель на строку зарегистрированного имени класса
        szClassName,
        // Указатель на строку заголовка окна
        szTitle,
        WS_OVERLAPPEDWINDOW,        // Стиль окна
        // Горизонтальная координата левого верхнего угла окна
        //   (используется умалчиваемое значение)
        CW_USEDEFAULT,
        // Вертикальная координата левого верхнего угла окна
        //   (используется умалчиваемое значение)
        CW_USEDEFAULT,
        CW_USEDEFAULT,              // Ширина окна (используется
                                    //   умалчиваемое значение)
        CW_USEDEFAULT,              // Высота окна (используется
                                    //   умалчиваемое значение)
        NULL,                       // Дескриптор родительского
                                    //   окна (его нет)
        NULL,                       // Дескриптор меню окна (его
                                    //   нет)
        hInstance,                  // Дескриптор экземпляра
                                    //   приложения
        NULL );                     // Указатель на дополнительные
                                    //   данные окна (их нет)
    if ( !hWnd )
        return FALSE;
    /*
       Аргументов в вызове CreateWindow( ) много, но назначение
    каждого из них очевидно. Первые два аргумента - имя класса и
    заголовок - выбраны нами произвольно и позволяют как системе,
    так и пользователю идентифицировать окно. Аргументы с
    четвертого по седьмой задают начальное положение и размеры
    окна. Константа CW_USEDEFAULT предписывает ОС Windows самой
    выбрать эти параметры. Это значение выбирается наиболее часто,
    но если необходимы некоторые конкретные величины, то можно
    указать их здесь. Следующие три аргумента определяют
    дескрипторы соответственно родительского окна, меню и самого
    приложения. Последний (одиннадцатый) аргумент позволяет
    ассоциировать с окном некоторые дополнительные данные. Функция
    возвращает дескриптор созданного окна ОС Windows.
       После возврата из функции CreateWindow( ) ОС Windows
    записывает в свою внутреннюю базу данных информацию,
    необходимую для сопровождения данного конкретного окна. Но при
    этом окно на экране не появляется - требуется вызов оставшихся
    двух функций, благодаря которым полностью оформленное окно
    появляется на экране.
       В вызове функции CreateWindow( ) остался еще один (третий)
    аргумент - стиль окна, который, ввиду важности, надо
    рассмотреть более подробно.
       Существует всего три основных типа окон - перекрывающиеся,
    всплывающие и дочерние, из которых программист может создавать
    множество самых разнообразных объектов, комбинируя
    предопределенные биты стиля. Рассмотрим эти биты, их влияние
    на внешний вид и некоторые свойства окон:
    WS_BORDER 
        Окно имеет рамку без заголовка
    WS_CAPTION
        Окно имеет заголовок и рамку. Как правило, этот стиль
    используется для перекрывающихся окон и не может применяться
    совместно со стилем WS_DLGFRAME
    WS_CHILD или WS_CHILDWINDOW
        Создаваемое окно является дочерним. Не может использоваться
    совместно со стилем WS_POPUP
    WS_CLIPCHILDREN
        Исключает область, занятую дочерним окном из области
    рисования родительского окна, и используется только для
    родительских окон
    WS_CLIPSIBLINGS
        Исключает все другие дочерние окна из своей области
    рисования. Другими словами, если дочерние окна перекрываются, а
    этот стиль не указан, то при изменении рабочей области одного
    из окон, могут быть испорчены рабочие области других дочерних
    окон. Этот стиль используется только вместе со стилем WS_CHILD
    WS_DISABLED
        Создается неактивное окно, т.е. сразу после создания оно не
    доступно для ввода с клавиатуры или с помощью мыши
    WS_DLGFRAME
        Окно имеет двойную рамку и не имеет заголовка
    WS_GROUP
        Определяет первый элемент управления группы окон, к которым
    пользователь может переходить при помощи клавиш со стрелками.
    Все элементы управления, определенные с этим стилем,
    заканчивают текущую и начинают новую группу (одна группа
    заканчивается там, где начинается другая)
    WS_HSCROLL
        Окно имеет горизонтальную полосу прокрутки
    WS_VSCROLL
        Окно имеет вертикальную полосу прокрутки
    WS_ICONIC или WS_MINIMIZE
        Создаваемое окно будет отображено в виде пиктограммы.
    Используется только со стилем WS_OVERLAPPED
    WS_MAXIMIZE
        Создаваемое окно при отображении будет иметь максимально
    возможный для него размер
    WS_MAXIMIZEBOX
        Создаваемое окно будет иметь кнопку максимизации
    WS_MINIMIZEBOX
        Создаваемое окно будет иметь кнопку минимизации
    WS_OVERLAPPED или WS_TILED
        Создаваемое окно является перекрывающимся. Обычно имеет
    заголовок и рамку
    WS_OVERLAPPEDWINDOW или WS_TILEDWINDOW
        Перекрывающееся окно с комбинацией стилей WS_OVERLAPPED,
    WS_CAPTION, WS_SYSMENU, WS_THICKFRAME, WS_MINIMIZEBOX и
    WS_MAXIMIZEBOX
    WS_POPUP 
        Создается всплывающее окно. Не может использоваться
    совместно со стилем WS_CHILD
    WS_POPUPWINDOW
        Всплывающее окно с комбинацией стилей WS_BORDER, WS_POPUP
    и WS_SYSMENU
    WS_SIZEBOX или WS_THICKFRAME
        Создаваемое окно имеет утолщенную рамку, при помощи которой
    можно изменять размер окна
    WS_SYSMENU 
        Создает окно с кнопкой системного меню (control-menu box) в
    полосе заголовка. Может быть использован только для окон с 
    полосой заголовка (необходимо дополнительно указать стиль
    WS_CAPTION)
    WS_TABSTOP
        Определяется для одного или нескольких элементов управления
    для того, чтобы между ними можно было перемещаться при помощи
    клавиши табуляции
    WS_VISIBLE
        Окно становится видимым сразу после создания
        Приведенные описания безусловно полезны и нужны, но очень
    полезно также поэкспериментировать, создавая окна с
    комбинациями различных стилей, чтобы увидеть их влияние.
        Теперь дадим краткую характеристику упомянутых выше
    основных типов окон ОС Windows:
        1. Перекрывающиеся окна (overlapped windows). Это основной,
    наиболее универсальный тип окон Windows. Для их создания чаще
    всего используется комбинированный стиль WS_OVERLAPPEDWINDOW.
    Главное окно приложения, как правило, имеет именно этот тип.
        2. Вспомогательные или всплывающие окна (popup windows).
    Чаще всего этот тип окон создается с использованием стиля
    WS_POPUP. Обычно они используются для отображения какой-либо
    информации на короткий промежуток времени. Наиболее часто окна
    этого типа применяются для отображения диалоговых окон или окон
    сообщений. Основное их отличие от других окон заключается в
    том, что даже если они имеют родительское окно, то все равно
    всегда отображаются поверх всех окон на экране, выскакивая, как
    поплавки, наверх даже тогда, когда пользователь делает активным
    другое окно. Для окон этого типа, как правило, организуется
    своя оконная процедура. Они могут и не иметь родителя. Если
    такое окно не имеет родительского, то оно является совершенно
    независимым от создавшего его окна и по своим свойствам
    практически не отличимо от перекрывающихся окон. Поведение
    всплывающего окна, имеющего родителя, зависит от того, что
    происходит с родительским окном. Когда главное окно
    минимизируется, всплывающее окно "без родителя" скрывается, а
    "с родителем" остается на экране сверху. Подчеркнем еще один
    важный момент. Когда мы говорим, что вспомогательное окно имеет
    родителя, то это совсем не означает, что оно является дочерним.
        3. Дочерние окна (child windows). Дочерние окна создаются
    тогда, когда у приложения уже есть главное окно. Такие окна
    связаны некоторыми характеристиками (как бы подчинены) с тем
    окном, из которого они были созданы - отсюда и такое название.
    Назначение таких окон может быть самым разнообразным, начиная
    от простого деления родительского окна на области до
    многодокументного интерфейса.
        Все элементы управления также являются дочерними окнами.
    Дочерние окна никогда не отображаются вне своего родительского
    окна ни в раскрытом виде, ни в виде пиктограммы - они как бы
    целиком принадлежат родителю. Располагаются они в родительском
    окне относительно верхнего левого угла его рабочей (клиентской)
    области. Более того, при перемещении родительского окна по
    экрану его дочерние окна перемещаются вместе с ним. И, наконец,
    дочернее окно никогда не может стать активным
    */

    // Показать окно с дескриптором hWnd: передает в ОС Windows
    //   информацию (nCmdShow) о том, в каком виде необходимо
    //   отобразить окно
    if ( ShowWindow( hWnd, nCmdShow ) ) 
        return FALSE;
    /*
       Обратите внимание, что второй аргумент, указанный в вызове
    функции ShowWindow( ), можно переопределить. Возможные
    значения аргумента nCmdShow:
    #define SW_HIDE             0
    #define SW_SHOWNORMAL       1
    #define SW_NORMAL           1
    #define SW_SHOWMINIMIZED    2
    #define SW_SHOWMAXIMIZED    3
    #define SW_MAXIMIZE         3
    #define SW_SHOWNOACTIVATE   4
    #define SW_SHOW             5
    #define SW_MINIMIZE         6
    #define SW_SHOWMINNOACTIVE  7
    #define SW_SHOWNA           8
    #define SW_RESTORE          9
    #define SW_SHOWDEFAULT      10
    #define SW_FORCEMINIMIZE    11
    #define SW_MAX              11
        Значения аргумента nCmdShow определяют следующие варианты
    отображения окна:
    SW_HIDE
        Скрыть указанное окно и активировать другое окно
    SW_MINIMIZE
        Свернуть указанное окно и активировать окно верхнего уровня
    (top level) в системном списке окон
    SW_SHOWMINIMIZED
        Активизировать и свернуть указанное окно
    SW_RESTORE или SW_NORMAL или SW_SHOWNORMAL
        Активировать и показать указанное окно. Если окно свернуто
    или максимизировано, то система восстанавливает его
    первоначальное положение и размеры
    SW_SHOW
        Активировать указанное окно и показать его с текущим
    положением и размерами
    SW_MAXIMIZED
        Максимизировать указанное окно
    SW_SHOWMAXIMIZED
        Активизировать и максимизировать указанное окно
    SW_SHOWMINNOACTIVE
        Показать указанное окно сврнутым в пиктограмму. Эффект этой
    константы похож на эффект от SW_SHOWMINIMIZED, за исключением
    того, что окно не активируется
    SW_SHOWNA
        Показать указанное окно с текущими положением и размерами.
    Прежнее активное окно остается активным
    SW_SHOWNOACTIVATE
        Показать указанное окно с его последним по времени
    положением и размерами. Прежнее активное окно остается активным
    */
    
    // Перерисовать окно: для перерисовки окна функция предписывает
    //   ОС Windows послать окну сообщение WM_PAINT
    if ( !UpdateWindow( hWnd ) ) 
        return FALSE;

    return TRUE;
}

/*
// ****************************************************************
// Оконная процедура - вариант 1.
//   Получает очередное сообщение и индивидуально обрабатывает его.
//   Вывод в клиентскую область окна не производится
LRESULT CALLBACK WndProc(           // Возвращает результат
                                    //   обработки сообщения,
                                    //   зависящий от посланного
                                    //   сообщения: 0 - успех
    HWND                hwnd,       // Дескриптор созданного окна
    UINT                message,    // Номер сообщения
    WPARAM              wParam,     // Дополнительная информация о 
    LPARAM              lParam )    //   сообщении, зависящая от
                                    //   типа сообщения (wParam,
                                    //   lParam)
{
    // Обработчик сообщения - в данном случае приложение явно
    //   отвечает иолько на сообщение WM_DESTROY, все остальные
    //   сообщения передаются в DefWindowProc( ) - функцию,
    //   управляющую поведением окна по умолчанию
    switch( message )
    {
    case WM_DESTROY:

        // Указывает системе, что сделан запрос о завершении
        //   приложения: 0 - код завершения. Вызов этой функции
        //   обычно используется в ответ на поступившее сообщение
        //   WM_DESTROY
        PostQuitMessage( 0 ); 
        break;

    default:

        // Обработка сообщения по умолчанию
        return DefWindowProc( hwnd, message, wParam, lParam );

    }

    return 0;
}
*/

// ****************************************************************
// Оконная процедура - вариант 2
//   Получает очередное сообщение и индивидуально обрабатывает его.
//   Обрабатывается вывод в клиентскую область окна
LRESULT CALLBACK WndProc(           // Возвращает результат
                                    //   обработки сообщения,
                                    //   зависящий от посланного
                                    //   сообщения: 0 - успех
    HWND                hwnd,       // Дескриптор созданного окна
    UINT                message,    // Номер сообщения
    WPARAM              wParam,     // Дополнительная информация о
    LPARAM              lParam )    //   сообщении, зависящая от
                                    //   типа сообщения (wParam,
                                    //   lParam)
{
    // Дескриптор контекста
    HDC                 hDC;
    // Указатель на структуру с информацией для приложения о
    //   клиентской области окна, используется для вывода в окно
    PAINTSTRUCT         ps;

    // Обработчик сообщения - в данном случае приложение явно
    //   отвечает только на сообщения WM_DESTROY и WM_PAINT, все
    //   остальные сообщения передаются в DefWindowProc( ) -
    //   функцию, управляющую поведением окна по умолчанию
    switch( message )
    {

    case WM_PAINT:

        COLORREF        oldColor,   // Старый цвет символов
                        oldBkColor; // Старый цвет фона символов
        HBRUSH          hNewBrush,  // Новая кисть
                        hOldBrush;  // Старая кисть
        HPEN            hNewPen,    // Новое перо
                        hOldPen;    // Старое перо

        // Для любого вывода в окно ОС Windows необходимо
        //   использовать функции GDI (Graphics Device Inerface),
        //   которые в качестве параметра используют контекст
        //   устройства. Обычно контекст устройства получают с
        //   помощью фунции BeginPaint( )
        hDC = BeginPaint( hwnd, &ps );
        if ( !hDC ) 
        {
            MessageBox( NULL, "Контекст устройства не получен",
                        "Ошибка 1", MB_OK );
            exit( 1 );
        }

        // Вывод заданного текста (четвертый аргумент, 27 - длина
        //   текста) в определенное место окна (второй и третий
        //   аргументы). Перед выводом текста задается цвет
        //   символов (зеленый) и цвет фона(черный). После вывода
        //   текста восстанавливаются прежние значения указанных
        //   параметров. Здесь макрос RGB(0, 255, 0) задает тройку
        //   чисел, определяющих цвет - первое число определяет
        //   значение красной составляющей, второе - зеленой и
        //   третье - синей
        oldColor = SetTextColor( hDC, RGB(0, 255, 0) );
        if ( oldColor == CLR_INVALID )
        {
            MessageBox( NULL, "Ошибка SetTextColor",
                        "Ошибка 2", MB_OK );
            exit( 2 );
        }
        oldBkColor = SetBkColor( hDC, RGB(0, 0, 0) );
        if ( oldBkColor == CLR_INVALID )
        {
            MessageBox( NULL, "Ошибка SetBkColor",
                        "Ошибка 3", MB_OK );
            exit( 3 );
        }
        if ( !TextOut( hDC, 150, 0, "Пример вывода текста в окно",
             27 ) )
        {
            MessageBox( NULL, "Неверное использование TextOut",
                        "Ошибка 4", MB_OK );
            exit( 4 );
        }
        SetTextColor( hDC, oldColor );
        SetBkColor( hDC, oldBkColor );
        // Об обработке ошибок этих функций см. выше - для
        //   сокращения размера исходного текста она опущена

        // Рисование линии: вначале выводится поясняющий текст
        //   (используется текущий цвет и фон), а затем - рисуется
        //   линия. Линия рисуется цветом текущего пера на текущем
        //   фоне. В функции MoveToEx( ) (125, 50) - новая текущая
        //   позиция в окне, а NULL означает, что старая текущая 
        //   позиция в окне не запоминается. Функция LineTo( )
        //   рисует линию из текущей позиции до точки (175, 100)
        // Об обработке ошибки этой функции см. выше - для
        //   сокращения размера исходного текста она опущена
        TextOut( hDC, 50, 30, "Пример вывода линии в окно", 26 );
        if ( !MoveToEx( hDC, 125, 50, NULL ) )
        {
            MessageBox( NULL, "Неверное использование MoveToEx",
                        "Ошибка 5", MB_OK );
            exit( 5 );
        }
        LineTo( hDC, 175, 100 );
        if ( !LineTo( hDC, 175, 100 ) )
        {
            MessageBox( NULL, "Неверное использование LineTo",
                        "Ошибка 6", MB_OK );
            exit( 6 );
        }

        // Рисование эллипса: вначале выводится поясняющий текст
        //   (используется текущий цвет и фон), а затем - рисуется
        //   эллипс. В функции Ellipse( ) (100, 140)  и (200, 240)
        //   - координаты левого верхнего и правого нижнего углов
        //   прямоугольника, в который вписан эллипс. Эллипс
        //   рисуется существующим пером, а внутренняя область
        //   эллипса закрашивается новой кистью (красной). После
        //   рисования старая кисть восстанавливаются
        // Об обработке ошибки этой функции см. выше - для
        //   сокращения размера исходного текста она опущена
        TextOut( hDC, 50, 120, "Пример вывода эллипса в окно",
                 28 );
        // Создаем зеленую кисть
        hNewBrush = CreateSolidBrush( RGB(255, 0, 0) );
        if ( !hNewBrush )
        {
            MessageBox( NULL, "Неверное использование "
                        "CreateSolidBrush", "Ошибка 7", MB_OK );
            exit( 7 );
        }
        // Включаем ее в контекст
        hOldBrush = static_cast< HBRUSH >( SelectObject( hDC,
            hNewBrush ) );
        if ( !hOldBrush )
        {
            MessageBox( NULL, "Неверное использование "
                        "SelectObject", "Ошибка 8", MB_OK );
            exit( 8 );
        }
        if ( !Ellipse( hDC, 100, 140, 200, 240 ) )
        {
            MessageBox( NULL, "Неверное использование "
                        "Ellipse", "Ошибка 9", MB_OK );
            exit( 9 );
        }
        // Удаляем новую кисть
        if ( !DeleteObject( hNewBrush ) )
        {
            MessageBox( NULL, "Неверное использование "
                        "DeleteObject", "Ошибка 10", MB_OK );
            exit( 10 );
        }
        // Восстанавливаем старую кисть. Об обработке ошибки этой
        //   функции см. выше - для сокращения размера исходного
        //   текста она опущена
        SelectObject( hDC, hOldBrush );

        // Рисование прямоугольника: вначале выводится поясняющий
        //   текст, а затем - рисуется прямоугольник. Перед
        //   рисованием прямоугольника задаются параметры пера для
        //   рисования прямоугольника. В функции Rectangle( )
        //   (100, 270) и (200, 370) - координаты левого верхнего
        //   и правого нижнего углов прямоугольника. Прямоугольник
        //   закрашивается текущей кистью. После рисования старое
        //   перо восстанавливается.
        // Об обработке ошибки этой функции см. выше - для
        //   сокращения размера исходного текста она опущена
        TextOut( hDC, 50, 250, "Пример вывода прямоугольника"
                 " в окно", 35 );
        // Создаем новое перо: точечное, толщиной 1, красного цвета
        hNewPen = CreatePen( PS_DOT, 1, RGB(255, 0, 0) );
        if ( !hNewPen )
        {
            MessageBox( NULL, "Неверное использование "
                        "CreatePen", "Ошибка 11", MB_OK );
            exit( 11 );
        }
		// Включаем его в контекст. Об обработке ошибки этой
        //   функции см. выше - для сокращения размера исходного
        //   текста она опущена
        hOldPen =
			static_cast< HPEN >( SelectObject( hDC, hNewPen ) );
        if ( !Rectangle( hDC, 100, 270, 200, 370 ) )
        {
            MessageBox( NULL, "Неверное использование "
                        "Rectangle", "Ошибка 12", MB_OK );
            exit( 12 );
        }
        // Удаляем новое перо. Об обработке ошибки этой функции см.
        //   выше - для сокращения размера исходного текста она
        //   опущена
        DeleteObject( hNewPen );
        // Восстанавливаем старое перо. Об обработке ошибки этой
        //   функции см. выше - для сокращения размера исходного
        //   текста она опущена
        SelectObject( hDC, hOldPen  );

        // Вывод информации в окно завершается вызовом функции
        //   EndPaint( ). Для каждого вызова BeginPaint( ) должен
        //   существовать соответствующий вызов EndPaint( )
        if ( !EndPaint( hwnd, &ps ) ) 
        {
            MessageBox( NULL, "Контекст устройства не освобожден",
                        "Ошибка 13", MB_OK );
            exit( 13 );
        }
        break;

    case WM_DESTROY:

        // Указывает системе, что сделан запрос о завершении
        //   приложения: 0 - код завершения. Вызов этой функции
        //   обычно используется в ответ на поступившее сообщение
        //   WM_DESTROY
        PostQuitMessage( 0 ); 
        break;

    default:

        // Обработка сообщения по умолчанию
        return DefWindowProc( hwnd, message, wParam, lParam );

    }

    return static_cast< LRESULT >( 0 );
}
